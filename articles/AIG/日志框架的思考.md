# 一种解决日志写入导致内存溢出（OOM）问题的高性能方法

https://mp.weixin.qq.com/s/WNYv6IxB8O8NnTLr8qFxVA
这篇文章主要介绍了一种解决日志写入导致内存溢出（OOM）问题的高性能方法。

文章首先指出，使用普通的同步写入方法（如 File.AppendAllText）处理大量日志（例如1000万条）时，会导致内存占用过高（示例中达到2.1GB），最终引发程序OOM崩溃。

接着，文章提出了一种高性能的解决方案，该方案结合使用了三项核心技术：
1.  对象池复用内存：利用 ArrayPool 来复用内存对象，减少创建和销毁对象带来的开销和内存压力。
2.  无锁队列异步：通过 Channel 实现生产者-消费者模式的异步处理，将日志写入操作与主业务逻辑解耦，避免阻塞。
3.  批量减少IO：将日志信息先缓存，然后进行批量写入，显著减少了磁盘I/O操作的次数，这是提升性能的关键。

采用这种新方法后，处理相同的1000万条日志，内存占用从2.1GB大幅降低到约10MB，性能提升了约100倍，并能保持稳定运行。

最后，文章提到在生产环境中，可以直接使用成熟的日志库（如 Serilog）来获得这些高性能特性，而无需手动实现。

在 C# 的现代日志框架（如 Serilog、NLog）中，“分工明确的管道”这一理念得到了非常清晰的体现。它指的是将日志生命周期的不同阶段（产生、处理、输出）解耦，由专门的、可插拔的组件各司其职。

最典型的例子就是 **Serilog**。它的核心架构完美诠释了这种管道式设计。

### 以 Serilog 为例的管道分工

Serilog 的日志流水线可以清晰地划分为以下几个“工位”：

1.  **日志记录创建（记录器）**
    *   **职责**：这是管道的起点。应用程序代码调用 `ILogger` 接口的方法（如 `Log.Information("Processing {OrderId}", orderId)`）来创建一个**日志事件**。这个事件包含了消息模板、级别、时间戳、异常以及属性（如 `OrderId`）等所有原始信息。
    *   **类比**：生产线上负责将原材料放入传送带的工人。

2.  **日志事件过滤与丰富（中间件/过滤器）**
    *   **职责**：在日志事件进入下一步之前，可以进行加工。这包括：
        *   **过滤**：根据日志级别、特定属性等条件决定是否让该日志事件继续向下传递。例如，在开发环境记录所有 `Debug` 级别以上的日志，而在生产环境只记录 `Warning` 级别以上的日志。
        *   **丰富**：向日志事件添加额外的属性信息，例如机器名、进程ID、线程ID、跟踪标识等。这通过 `Enrich.With*()` 方法实现。
    *   **类比**：质量检测站和加工站，筛选掉不合格品，并为合格品贴上额外的标签。

3.  **日志事件汇集与缓冲（异步接收器核心）**
    *   **职责**：这正是您上一个问题中提到的“后台消费者”。Serilog 通过配置 `Async` 包装器，将日志事件放入一个内存中的**缓冲区队列**。应用程序的日志调用会立即返回，不会阻塞。一个后台线程则从这个队列中持续取出日志事件。
    *   **类比**：一个中央仓库或缓冲区，接收来自生产线的产品，并按节奏分发给后续的打包发货部门。

4.  **日志事件输出（接收器）**
    *   **职责**：这是管道的终点，负责将格式化后的日志事件写入到指定的目标地。Serilog 的强大之处在于其丰富的**接收器**生态系统。每个接收器专精于一种输出：
        *   **文件接收器**：将日志写入滚动文件。
        *   **控制台接收器**：将日志输出到开发环境的控制台。
        *   **Seq 接收器**：将日志推送到 Seq 这类专业的日志服务器。
        *   **Elasticsearch 接收器**：将日志推送到 Elasticsearch 集群。
    *   在输出前，日志事件还会根据接收器配置的**输出模板**被格式化成文本（如 JSON、纯文本）。
    *   **类比**：不同的发货渠道。有的产品打包装箱发往仓库（文件），有的直接展示给顾客看（控制台），有的则通过快递发往中央处理中心（Seq/Elasticsearch）。

### 一个具体的配置代码示例

下面的代码清晰地展示了这条“管道”是如何搭建的：

```csharp
// 创建 Serilog 日志管道
Log.Logger = new LoggerConfiguration()
    // 1. 过滤：设置最低日志级别
    .MinimumLevel.Information()
    // 2. 丰富：为所有日志事件添加“应用程序名称”和“机器名”属性
    .Enrich.WithProperty("Application", "MyWebApp")
    .Enrich.WithMachineName()
    // 3 & 4. 输出：配置接收器，并用 Async() 包装实现异步缓冲
    .WriteTo.Async(a => a.File( // 输出到文件
        path: "logs/myapp-.txt",
        rollingInterval: RollingInterval.Day, // 按天滚动文件
        outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss} [{Level}] {Message}{NewLine}{Exception}"
    ))
    .WriteTo.Async(a => a.Console()) // 同时输出到控制台
    .CreateLogger();

// 应用程序中使用（管道的起点）
try
{
    Log.Information("Starting web host...");
    // ... 你的业务代码
    Log.Information("Processed order {OrderId} for {Customer}", orderId, customerName);
}
finally
{
    // 确保所有缓冲的日志都被写出
    Log.CloseAndFlush();
}
```

**总结一下**：

在 C# 日志框架（特别是 Serilog）中，“分工明确的管道”体现在其**高度模块化和可配置的架构**上。`Logger` 负责创建，`Enricher` 负责加工，`Filter` 负责筛选，异步队列负责缓冲，而各种 `Sink` 负责最终输出。每个组件只专注于一件事，通过管道组合起来，共同实现了高性能、高灵活性且功能强大的日志记录能力。这正是现代化日志库解决传统同步写入性能问题的核心设计思想。