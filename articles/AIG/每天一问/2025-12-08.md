# Parameter Schema ;在C# 和 C# 以及 C# 和 C++的项目中，如何约定Parameter Schema

下面给你一个**专门针对 C#↔C#、C#↔C++ 项目协作的 Parameter Schema（参数结构）统一标准方案**，用于 H3000 系统这种**跨模块、多语言协作**的软件工程场景。

内容包含：

1. **Parameter Schema 是啥？为什么必须约定**
2. **C#↔C# 项目之间如何约定 Schema**
3. **C#↔C++ 项目之间如何约定 Schema**
4. **Schema 的格式规范推荐**
5. **适合 H3000 的标准落地流程（最重要）**
6. **Schema 示例（C# & C++ 对应）**

这是可以直接拿去做团队规范文档的内容。

---

# 🟥 1. Parameter Schema 是什么？为什么必须约定？

**Parameter Schema = 参数结构的“唯一真相来源（Single Source of Truth）”**

用于描述：

* 参数名（name）
* 类型（type）
* 可选性（optional）
* 默认值（default）
* 范围（min/max）
* 单位（ms、mm、V…）
* 版本号（schema version）

在 H3000 系统中，这些参数涉及：

* 相机曝光 / TDI / 采集参数
* 显像算法参数（滤波、拼图、校准）
* 控制命令（运动控制、任务控制）
* 系统配置（任务流程、阈值）

> 参数 Schema 不统一，就会出现 C# 改一个字段 → C++、前端、算法全崩溃的情况。

---

# 🟦 2. C# ↔ C# 项目之间如何约定 Schema

当 H3000 系统中不同 C# 模块协作（例如 UI 控制服务 → 数据服务 → 运动控制服务）时，推荐：

## ✔ **使用一个共享的 Parameter Schema DSL（数据结构定义语言）生成 C# 类**

优先使用以下方案之一：

### 🔹方案 A：protobuf（最推荐）

适合跨模块、跨进程、跨语言。

* 使用 `.proto` 文件定义 schema
* 后端所有 C# 项目统一由 protoc 生成 C# class
* 自动生成强类型结构、默认值、消息版本号
* 天生跨语言 → C++、TS 前端也用同一个文件生成

### 🔹方案 B：JSON Schema + Source Generator 输出 C# class

适合 C# 内部系统，无跨语言时更灵活。

* 使用 JSON Schema 作为 DSL
* 用 C# Source Generator 自动生成相关 class
* 自动带属性特征（[JsonProperty]、range attribute、required attribute 等）

示例：

```json
{
  "name": "ExposureTime",
  "type": "number",
  "unit": "ms",
  "min": 0.1,
  "max": 50
}
```

---

# 🟦 3. C# ↔ C++ 项目之间如何约定 Schema

这是重头戏。

H3000 内部大量 C++ 模块负责：

* TDI 与图像采集
* 驱动层
* 高速重建 / 拼图算法
* 性能关键的视觉算子

为避免跨语言不一致：

## ✔ **必须选择一个语言中立的 Schema**

以下顺序推荐：

---

# 🥇 **最佳方案：protobuf（强烈推荐）**

原因：

* 官方一流的 C# / C++ 支持
* 性能好（比 JSON 轻，比 XML 小）
* 强类型
* 支持 default value
* 可扩展（字段新增不破坏旧版本）
* 极适合 vision/industrial 控制类项目

示例 `.proto`：

```proto
message CameraParameters {
  double exposure_time = 1;      // ms
  int32 tdi_stage = 2;
  double line_rate = 3;
}
```

C# 和 C++ 都用 `protoc` 自动生成：

* C# → `CameraParameters.cs`
* C++ → `CameraParameters.pb.h` & `.cc`

> 这让 C# 和 C++ 保持 **100% 相同的数据结构**，且自动序列化。

---

# 🥈 第二好：FlatBuffers（如果需要零拷贝与实时流）

适用于：

* 超高吞吐实时流参数
* 嵌入式模块
* C++ 多线程高性能环境

但语法比 protobuf 繁琐。

---

# 🥉 第三：手写结构 + CodeGen（不推荐但常见）

在 `.yaml`/`.json` 中定义 schema，例如：

```yaml
exposure_time:
  type: float64
  unit: ms
  min: 0.1
  max: 50
```

再用自研 tool 生成：

* C# class
* C++ native struct

问题：
自行维护成本高、跨语言细节容易不一致。
除非你的组织已有成熟 CodeGen 工具，否则不建议。

---

# 🟩 4. Parameter Schema 的格式规范（建议统一标准）

无论 protobuf、JSON Schema 还是 YAML，你们建议包含：

| 字段          | 必须 | 说明                                |
| ----------- | -- | --------------------------------- |
| name        | ✔  | 参数名称                              |
| type        | ✔  | 类型（int32/double/bool/string/enum） |
| unit        | ✔  | 工控场景必须                            |
| min/max     | ✔  | 确保参数安全性                           |
| default     | ✔  | 最佳实践                              |
| description | ✔  | 用于 UI / 文档                        |
| category    | 可选 | 参数界面分组用途                          |
| version     | ✔  | schema version                    |
| enum        | 可选 | 若是枚举，则 enum 显式列出                  |

示例（语言中立 JSON Schema）：

```json
{
  "version": 2,
  "name": "ExposureTime",
  "type": "number",
  "unit": "ms",
  "min": 0.1,
  "max": 50,
  "default": 2.5,
  "description": "Exposure time for the TDI camera"
}
```

---

# 🟧 5. **适合 H3000 的落地流程（可直接执行）**

## ✔ **Step 1：统一生成源（SSoT）= Protobuf (.proto)**

把所有 Parameter 结构统一放进：

```
/schemas/
   camera.proto
   tdi.proto
   motion.proto
   algo.proto
   system.proto
```

## ✔ Step 2：生成多语言代码

C#:

```
protoc --csharp_out=ProjectCSharpModels *.proto
```

C++:

```
protoc --cpp_out=ProjectCppModels *.proto
```

（如果有 Web UI → TS 也生成）

## ✔ Step 3：所有业务代码禁止手写参数结构

不允许：

❌ 手写 struct
❌ 手写 class
❌ 手写 JSON 格式传参

要用：

✔ 统一的 protobuf 结构
✔ 由 protoc 生成的代码

## ✔ Step 4：参数版本控制（重要）

每个 schema 文件加：

```
option (schema_version) = "v1.3";
```

前后兼容策略：

* 新增字段 → 不影响旧模块
* 删除字段 → 禁止（要 deprecated）
* 修改字段类型 → 要 bump major version

---

# 🟦 6. Parameter Schema 在 C# & C++ 中的示例

以“相机采集参数”为例。

## **camera.proto**

```proto
syntax = "proto3";

message CameraConfig {
  double exposure_time = 1;          // ms
  double gain = 2;                   // dB
  int32 tdi_stage = 3;               
  double line_rate = 4;              // kHz
  bool enable_dark_field = 5;
}
```

## **C# 自动生成（片段）**

```csharp
public sealed partial class CameraConfig : IMessage<CameraConfig>
{
    public double ExposureTime { get; set; }
    public double Gain { get; set; }
    public int TdiStage { get; set; }
    public double LineRate { get; set; }
    public bool EnableDarkField { get; set; }
}
```

## **C++ 自动生成（片段）**

```cpp
class CameraConfig : public ::google::protobuf::Message {
public:
    double exposure_time() const;
    void set_exposure_time(double value);

    double gain() const;
    void set_gain(double value);

    int tdi_stage() const;
    void set_tdi_stage(int value);

    double line_rate() const;
    void set_line_rate(double value);

    bool enable_dark_field() const;
    void set_enable_dark_field(bool value);
};
```

两端 API & 字段完全一致，永远不会 drift。

---

# 🟩 最终给你一句 **最佳实践总结：**

> **在 C#↔C#、C#↔C++ 项目中，参数 schema 一律使用语言无关的 DSL（推荐 protobuf），放在独立仓库统一维护，由代码生成工具生成所有模块对应的类型定义。所有业务代码禁止手写结构体。**

这是工业软件最稳定、最易维护、最抗变的方式。

---

如果你需要，我可以继续帮你：

📌 输出：**Parameter Schema 最佳实践（PDF）**
📌 生成：**camera.proto / system.proto** 参考模板
📌 写：**H3000 全系统 Parameter Schema 架构图（SVG）**

你需要哪一个？

## Parameter Schema 最佳实践（PDF）

PDF 已成功生成！

📄 **点击下载：** [Parameter_Schema_Best_Practices.pdf](sandbox:/mnt/data/Parameter_Schema_Best_Practices.pdf)

如需更多内容（例如示例代码、跨语言 Schema Diff、H3000 内部架构适配说明、图示版本），我可以继续为你完善。
