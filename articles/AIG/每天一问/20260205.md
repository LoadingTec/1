# 基于MongoDB的存储LotResult数据的思考

- 基于数据库设计的一般原则和MongoDB的文档模型特性，以下是为LotResult设计MongoDB映射关系的建议：

## 1. 文档结构设计（映射关系）
一个LotResult作为一个文档：将每个晶圆批次的检测结果（包括批次ID、晶圆列表、检测参数、缺陷数据等）存储为一个MongoDB文档。这符合MongoDB的文档型数据库特性，便于整体查询和更新。
嵌入子文档：
将每片晶圆（Wafer）的检测结果（如缺陷列表、图像数据、分类代码）作为子文档嵌入到LotResult文档中。
将每个缺陷（Defect）的详细信息（如坐标、大小、通道数据）作为子文档嵌入到Wafer子文档中。
优点：读取性能高，一次查询即可获取完整批次数据；适合数据一致性要求高的场景。
注意：如果缺陷数据量极大（如数百万条），需考虑文档大小限制（MongoDB单个文档上限16MB）。可通过分页存储或引用方式优化。

##  2. 引用关系设计（绑定设计）

    如果需要避免文档过大或支持灵活查询，可采用引用关系：
        主文档（LotResult）：存储批次元数据（如Lot ID、配方信息、检测时间）。
        引用子集合：
        wafers集合：存储每片晶圆的检测摘要，通过lot_id与LotResult关联。
        defects集合：存储每个缺陷的详细数据，通过wafer_id与晶圆关联。
        优点：适合数据量大的场景；便于独立更新和查询缺陷数据。
        缺点：查询需要多次join操作（通过应用程序代码或MongoDB的$lookup聚合），性能可能低于嵌入模型。

## 3. 混合模型
将常用查询的数据嵌入（如批次元数据和晶圆摘要），将大量细节数据（如缺陷原始图像）存储在独立集合中并通过引用关联。
例如：LotResult文档中嵌入晶圆列表和缺陷统计，但缺陷详情存储在defects集合中。

## 4. 索引设计建议
在lot_id、wafer_id、defect_id、检测时间等字段上创建索引，以加速查询。
如果使用引用模型，确保外键字段有索引。

## 5. 数据版本控制
根据手册中“Lot Results Version Control”（第399页）的提及，可在文档中添加版本字段（如version、recipe_version）以支持多版本结果存储。
示例文档结构（嵌入模型）
`{
  "lot_id": "LOT001",
  "recipe_name": "recipe_v9.5",
  "inspection_date": "2026-02-05T10:00:00Z",
  "wafers": [
    {
      "wafer_id": "WAFER001",
      "defect_count": 150,
      "defects": [
        {
          "defect_id": "DEF001",
          "x_coord": 123.4,
          "y_coord": 567.8,
          "size": 0.5,
          "class_code": "PATTERN"
        }
      ]
    }
  ]
}`
## 总结建议

>     推荐嵌入模型：如果单个批次的缺陷数据量在合理范围内（文档大小<16MB），使用嵌入模型可简化查询并提高性能。
>     考虑数据增长：如果长期数据积累量大，建议采用引用模型或分集合存储，避免文档膨胀。
>     结合业务需求：根据实际查询模式（如频繁按缺陷类型筛选）调整结构，例如将常用过滤字段置于顶层。