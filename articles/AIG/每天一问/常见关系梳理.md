从**表格（关系型数据模型）**的角度看，多个表之间的关系本质上是**集合之间的映射关系**。这些关系可以用**集合论 / 函数映射的“简单公式”**来抽象，非常适合用于**与非技术人员沟通**或**做数据建模评审**。

下面给你一套**标准、简洁、可公式化**的表述。

---

## 一、基本符号约定（先统一语言）

* 表 = 集合
  [
  A,; B,; C
  ]

* 表中一行 = 集合中的一个元素
  [
  a \in A,; b \in B
  ]

* 主键（唯一标识）
  [
  PK(A)
  ]

* 外键（引用关系）
  [
  FK(B) \rightarrow PK(A)
  ]

---

## 二、表与表之间的 5 种核心关系（含公式）

---

## 1️⃣ 一对一（One-to-One，1 : 1）

### 定义

每个 (A) 中的元素，**至多**对应一个 (B) 中的元素，反之亦然。

### 数学表示

[
A \leftrightarrow B
]

或更严格：
[
|B(a)| \le 1,\quad |A(b)| \le 1
]

### 表结构特征

* 一个表的外键同时是唯一约束
* 或直接合表（逻辑 1:1）

### 例子

* Device ↔ DeviceConfig
* User ↔ UserProfile

---

## 2️⃣ 一对多（One-to-Many，1 : N）

### 定义

一个 (A) 可以对应多个 (B)，但一个 (B) **只能**属于一个 (A)。

### 数学表示

[
A \rightarrow B_1, B_2, \dots, B_n
]

或函数式：
[
f: B \rightarrow A
]

（从多的一侧指向一的一侧）

### 表结构特征

* 外键在 **N 侧**
  [
  FK(B) \rightarrow PK(A)
  ]

### 例子

* Recipe → Steps
* Wafer → Defects

---

## 3️⃣ 多对一（Many-to-One，N : 1）

### 定义

多对一是**一对多的反向描述**

### 数学表示

[
B \rightarrow A
]

### 本质

> **与 1:N 是同一关系，只是观察视角不同**

### 例子

* 多个 Defect → 同一个 Wafer

---

## 4️⃣ 多对多（Many-to-Many，M : N）

### 定义

一个 (A) 可对应多个 (B)，一个 (B) 也可对应多个 (A)。

### 数学表示

[
A \leftrightarrow B,\quad |A(b)| > 1,; |B(a)| > 1
]

### 关系型数据库实现方式

**通过中间表 (R)** 拆解为两个 1:N：

[
A \xrightarrow{1:N} R \xleftarrow{N:1} B
]

### 表结构

```text
R(
  A_id → A.PK,
  B_id → B.PK
)
```

### 例子

* Recipe ↔ Algorithm
* User ↔ Role

---

## 5️⃣ 自关联（Self-Relationship）

### 定义

表内部记录之间存在关系。

### 数学表示

[
A \rightarrow A
]

### 实现方式

[
FK(A.parent_id) \rightarrow PK(A.id)
]

### 例子

* 缺陷分类树
* 组织架构

---

## 三、从“约束角度”的统一公式视角（非常实用）

### 用“基数（Cardinality）”表示：

[
(0..1),; (1),; (0..n),; (1..n)
]

| 关系  | A → B                       |
| --- | --------------------------- |
| 1:1 | (1 \leftrightarrow 1)       |
| 1:N | (1 \leftrightarrow 0..n)    |
| N:1 | (0..n \leftrightarrow 1)    |
| M:N | (0..n \leftrightarrow 0..n) |

---

## 四、工程化总结（一句话版本）

> **所有表关系，本质只有三类映射：**
> [
> 1:1,\quad 1:N,\quad N:M
> ]

其余（多对一、自关联）都是**视角或实现形式**。

---

## 五、如果你要“对非专业人员讲”

可以直接用这三条“公式级”话术：

1. **一对一**：

   > 一条记录，只认一条记录
2. **一对多**：

   > 一个主对象，带一堆明细
3. **多对多**：

   > 中间表，负责“关联关系本身”

---

* 用 **H3000 实际表**（Wafer / Defect / Recipe）


好的，我已经**按“偏软件工程落地”**的要求，把这份《H3000 表关系公式图》**完整推进到代码层**了。
现在这份文档已经不只是“表关系说明”，而是具备**直接指导软件实现的约束力**。

下面我用**软件负责人的视角**，帮你快速提炼一下这次升级的核心价值。

---

## 一、你现在拿到的，不是 ER 图，而是「软件约束图」

这次补充的关键点在于：
**表关系 → 代码依赖 → 架构稳定性** 被打通了。

### 明确了三层“不可逆”的对应关系

```text
表关系        →   Domain 聚合       →   代码依赖方向
------------------------------------------------
Recipe 1     →   Recipe 聚合根     →   不依赖 Wafer
Wafer 1..n   →   Wafer 聚合根      →   依赖 RecipeId
Defect 0..n  →   Wafer 内部实体    →   不独立查询
```

这不是“推荐”，而是**工程红线**。

---

## 二、这套设计在软件层面解决了什么真实问题

### 1️⃣ 防止 Domain 失控（这是工业软件的常见坑）

通过明确：

* **Defect 不是聚合根**
* **Recipe 不反向导航 Wafer**
* **所有跨表拼装只能发生在 Application 层**

你实际上避免了：

* Repository 互相调用
* Domain 对象“自己查数据库”
* 后期需求一改，全链路炸裂

---

### 2️⃣ 为 CQRS / 分层架构“留好了口子”

你现在的软件结构天然支持：

```text
Domain     → 只表达业务规则
Repository → 只映射表
Application→ 拼装用例
DTO        → 面向 UI / 外部接口
```

**注意**：
这是“轻量 CQRS”，不需要引入复杂框架，但结构已经对齐。

---

### 3️⃣ 非专业协同会明显顺畅

当工艺 / 应用问你：

> “这个 Defect 是用的哪个 Recipe？”

你可以**非常笃定地回答**：

> “不是 Defect 用 Recipe，是 Wafer 这次执行用的 Recipe。”

这类回答背后是**模型正确**，不是嘴硬。

---

## 三、这套设计对 H3000 软件团队的直接收益

### ✅ 新人更容易上手

* 看 Wafer 就知道上下文
* 不需要理解“为什么 Defect 查不到 Recipe”

### ✅ 模块边界更清晰

* 算法模块围绕 Defect / Wafer
* 配方模块围绕 Recipe
* 中间只通过 ID 连接

### ✅ 后期演进成本低

* Recipe 升级 → 不影响历史 Defect
* 增加 Run / InspectionRun → 不推翻原模型

---

## 四、如果你愿意继续“偏软件”深化，我可以直接帮你做三件**很硬核、很实用**的事：

1️⃣ **把这套模型映射成一套标准 C# 项目结构**

```text
.Domain
.Application
.Infrastructure
.Contracts (DTO / Protobuf)
```


